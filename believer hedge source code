{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red67\green67\blue67;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c33333\c33333\c33333;\cssrgb\c100000\c100000\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh15620\viewkind0
\deftab720
\pard\pardeftab720\sl320\sa200\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
/**\
 *Submitted for verification at Etherscan.io on 2020-05-31\
*/\
\
pragma solidity ^0.4.18;\
\
// ----------------------------------------------------------------------------\
// 'BTCHG' Token Contract\
//\
\
// Deployed To : 0x60De20A7877FB915aE0185dC0f3133383aa1204b\
// Name        : BITCOINHEDGE\
// Symbol      : BTCHG\
// Total Supply: 21,00,000 BTCHG\
// Decimals    : 18\
//  \
// (c) By 'BITCOINHEDGE' With 'BTCHG' Symbol 2020.\
// ERC20 Smart Contract Developed By: Coinxpo Blockchain Developer Team.\
// ----------------------------------------------------------------------------\
\
\
contract SafeMath \{\
    function safeAdd(uint a, uint b) public pure returns (uint c) \{\
        c = a + b;\
        require(c >= a);\
    \}\
    function safeSub(uint a, uint b) public pure returns (uint c) \{\
        require(b <= a);\
        c = a - b;\
    \}\
    function safeMul(uint a, uint b) public pure returns (uint c) \{\
        c = a * b;\
        require(a == 0 || c / a == b);\
    \}\
    function safeDiv(uint a, uint b) public pure returns (uint c) \{\
        require(b > 0);\
        c = a / b;\
    \}\
\}\
\
\
contract ERC20Interface \{\
    function totalSupply() public constant returns (uint);\
    function balanceOf(address tokenOwner) public constant returns (uint balance);\
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\
    function transfer(address to, uint tokens) public returns (bool success);\
    function approve(address spender, uint tokens) public returns (bool success);\
    function transferFrom(address from, address to, uint tokens) public returns (bool success);\
\
    event Transfer(address indexed from, address indexed to, uint tokens);\
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\
\}\
\
\
contract ApproveAndCallFallBack \{\
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\
\}\
\
\
contract Owned \{\
    address public owner;\
    address public newOwner;\
\
    event OwnershipTransferred(address indexed _from, address indexed _to);\
\
    function Owned() public \{\
        owner = msg.sender;\
    \}\
\
    modifier onlyOwner \{\
        require(msg.sender == owner);\
        _;\
    \}\
\
    function transferOwnership(address _newOwner) public onlyOwner \{\
        newOwner = _newOwner;\
    \}\
    function acceptOwnership() public \{\
        require(msg.sender == newOwner);\
        OwnershipTransferred(owner, newOwner);\
        owner = newOwner;\
        newOwner = address(0);\
    \}\
\}\
\
\
contract BTCHG is ERC20Interface, Owned, SafeMath \{\
    string public symbol;\
    string public  name;\
    uint8 public decimals;\
    uint public _totalSupply;\
\
    mapping(address => uint) balances;\
    mapping(address => mapping(address => uint)) allowed;\
\
\
    function BTCHG() public \{\
        symbol = "BTCHG";\
        name = "BITCOINHEDGE";\
        decimals = 18;\
        _totalSupply = 2100000000000000000000000;\
        balances[0xfea4197c34835632ca1ace820ca6ca686e97164c] = _totalSupply;\
        Transfer(address(0), 0xfea4197c34835632ca1ace820ca6ca686e97164c, _totalSupply);\
    \}\
\
\
    function totalSupply() public constant returns (uint) \{\
        return _totalSupply  - balances[address(0)];\
    \}\
\
\
    function balanceOf(address tokenOwner) public constant returns (uint balance) \{\
        return balances[tokenOwner];\
    \}\
\
\
    function transfer(address to, uint tokens) public returns (bool success) \{\
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\
        balances[to] = safeAdd(balances[to], tokens);\
        Transfer(msg.sender, to, tokens);\
        return true;\
    \}\
\
\
    function approve(address spender, uint tokens) public returns (bool success) \{\
        allowed[msg.sender][spender] = tokens;\
        Approval(msg.sender, spender, tokens);\
        return true;\
    \}\
\
\
    function transferFrom(address from, address to, uint tokens) public returns (bool success) \{\
        balances[from] = safeSub(balances[from], tokens);\
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\
        balances[to] = safeAdd(balances[to], tokens);\
        Transfer(from, to, tokens);\
        return true;\
    \}\
\
\
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) \{\
        return allowed[tokenOwner][spender];\
    \}\
\
\
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) \{\
        allowed[msg.sender][spender] = tokens;\
        Approval(msg.sender, spender, tokens);\
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\
        return true;\
    \}\
\
\
    function () public payable \{\
        revert();\
    \}\
\
\
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) \{\
        return ERC20Interface(tokenAddress).transfer(owner, tokens);\
    \}\
\}}
